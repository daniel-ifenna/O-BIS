{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/constructionplatform%20%281%29/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\nconst globalForPrisma = globalThis as unknown as { prisma?: PrismaClient }\n\nconst dbUrl = process.env.DATABASE_URL_PGBOUNCER || process.env.DATABASE_URL || \"\"\n\nfunction createPrismaOrMock(): PrismaClient | any {\n  if (dbUrl) {\n    return new PrismaClient({\n      datasources: {\n        db: { url: dbUrl },\n      },\n    })\n  }\n  const warn = (op: string) => {\n    throw new Error(`Database unavailable: set DATABASE_URL before calling ${op}`)\n  }\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        if (prop === \"$use\") return () => {}\n        if (prop === \"$transaction\") return () => warn(\"$transaction\")\n        return () => warn(String(prop))\n      },\n    },\n  ) as PrismaClient\n}\n\nexport const prisma = globalForPrisma.prisma || createPrismaOrMock()\n\nif (!globalForPrisma.prisma) globalForPrisma.prisma = prisma\n\nfunction fmtDate(d: Date): string {\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, \"0\")\n  const day = String(d.getDate()).padStart(2, \"0\")\n  return `${y}-${m}-${day}`\n}\n\nfunction fmtTime(d: Date): string {\n  const h = String(d.getHours()).padStart(2, \"0\")\n  const min = String(d.getMinutes()).padStart(2, \"0\")\n  return `${h}:${min}`\n}\n\nconst TARGET_MODELS = new Set([\n  \"User\",\n  \"Contractor\",\n  \"Vendor\",\n  \"Manager\",\n  \"Project\",\n  \"Bid\",\n  \"BidInvitation\",\n  \"ProcurementRequest\",\n  \"EscrowWalletTransaction\",\n  \"FileStorageRecord\",\n  \"PaymentRequest\",\n  \"Milestone\",\n  \"DailyReport\",\n  \"VendorQuote\",\n])\n\nif (typeof (prisma as any).$use === \"function\") (prisma as any).$use(async (params: any, next: any) => {\n  const now = new Date()\n  const date = fmtDate(now)\n  const time = fmtTime(now)\n  const modelMatches = TARGET_MODELS.has(params.model || \"\")\n  const preventDeletes = String(process.env.ALLOW_DELETE || \"\").toLowerCase() !== \"true\"\n  if (preventDeletes && (params.action === \"delete\" || params.action === \"deleteMany\")) {\n    throw new Error(\"Delete operations are disabled\")\n  }\n\n  if (modelMatches) {\n    if (params.action === \"create\") {\n      params.args.data = { ...(params.args.data || {}), recordDate: date, recordTime: time }\n    } else if (params.action === \"createMany\") {\n      const data = params.args.data\n      if (Array.isArray(data)) {\n        params.args.data = data.map((item: any) => ({ ...(item || {}), recordDate: date, recordTime: time }))\n      } else {\n        params.args.data = { ...(data || {}), recordDate: date, recordTime: time }\n      }\n    } else if (params.action === \"update\" || params.action === \"upsert\") {\n      params.args.data = { ...(params.args.data || {}), recordDate: date, recordTime: time }\n    } else if (params.action === \"updateMany\") {\n      const data = params.args.data\n      params.args.data = { ...(data || {}), recordDate: date, recordTime: time }\n    }\n  }\n\n  return next(params)\n})\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/constructionplatform%20%281%29/lib/auth/reset.ts"],"sourcesContent":["import * as jwt from \"jsonwebtoken\"\nimport { prisma } from \"@/lib/db\"\n\nfunction fmtDate(d: Date): string {\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, \"0\")\n  const day = String(d.getDate()).padStart(2, \"0\")\n  return `${y}-${m}-${day}`\n}\n\nfunction fmtTime(d: Date): string {\n  const h = String(d.getHours()).padStart(2, \"0\")\n  const min = String(d.getMinutes()).padStart(2, \"0\")\n  return `${h}:${min}`\n}\n\nexport async function issueResetToken(userId: string, expiresIn = process.env.JWT_EXPIRES_IN || \"24h\"): Promise<{ token: string; recordDate: string; recordTime: string; expiresAt: string }> {\n  const secret = process.env.JWT_SECRET || \"\"\n  if (!secret) throw new Error(\"Missing JWT_SECRET\")\n  const now = new Date()\n  const token = jwt.sign({ sub: userId, type: \"password_reset\" } as jwt.JwtPayload, secret as jwt.Secret, { expiresIn } as jwt.SignOptions)\n  const decoded = jwt.decode(token) as any\n  const expMs = decoded?.exp ? decoded.exp * 1000 : now.getTime() + 24 * 60 * 60 * 1000\n  const expiresAt = new Date(expMs).toISOString()\n  const recordDate = fmtDate(now)\n  const recordTime = fmtTime(now)\n\n  await (prisma as any).passwordResetToken.create({ data: { token, userId, issuedAt: now, expiresAt: new Date(expiresAt), used: false, recordDate, recordTime } })\n  return { token, recordDate, recordTime, expiresAt }\n}\n\nexport async function validateResetToken(token: string): Promise<{ valid: boolean; userId?: string; reason?: string }> {\n  const secret = process.env.JWT_SECRET || \"\"\n  if (!secret) return { valid: false, reason: \"Missing JWT_SECRET\" }\n  try {\n    const payload = jwt.verify(token, secret as jwt.Secret) as any\n    if (payload?.type !== \"password_reset\") return { valid: false, reason: \"Invalid token type\" }\n    const rec = await (prisma as any).passwordResetToken.findUnique({ where: { token } })\n    if (!rec) return { valid: false, reason: \"Token not found\" }\n    if (rec.used) return { valid: false, reason: \"Token already used\" }\n    if (new Date(rec.expiresAt).getTime() < Date.now()) return { valid: false, reason: \"Token expired\" }\n    return { valid: true, userId: rec.userId }\n  } catch (e: any) {\n    return { valid: false, reason: e?.message || \"Invalid token\" }\n  }\n}\n\nexport async function consumeResetToken(token: string): Promise<void> {\n  await (prisma as any).passwordResetToken.update({ where: { token }, data: { used: true } })\n}\n\nexport async function issueVerificationToken(userId: string, expiresIn = process.env.JWT_EXPIRES_IN || \"24h\"): Promise<{ token: string; recordDate: string; recordTime: string; expiresAt: string }> {\n  const secret = process.env.JWT_SECRET || \"\"\n  if (!secret) throw new Error(\"Missing JWT_SECRET\")\n  const now = new Date()\n  const token = (jwt as any).sign({ sub: userId, type: \"email_verification\" }, secret, { expiresIn })\n  const decoded: any = (jwt as any).decode(token)\n  const expMs = decoded?.exp ? decoded.exp * 1000 : now.getTime() + 24 * 60 * 60 * 1000\n  const expiresAt = new Date(expMs).toISOString()\n  const recordDate = fmtDate(now)\n  const recordTime = fmtTime(now)\n  const m = (prisma as any).emailVerificationToken\n  const alt = (prisma as any).passwordResetToken\n  if (m && typeof m.create === \"function\") {\n    await m.create({ data: { token, userId, issuedAt: now, expiresAt: new Date(expiresAt), used: false, recordDate, recordTime } })\n  } else if (alt && typeof alt.create === \"function\") {\n    await alt.create({ data: { token, userId, issuedAt: now, expiresAt: new Date(expiresAt), used: false, recordDate, recordTime } })\n  } else {\n    throw new Error(\"Verification token storage unavailable\")\n  }\n  return { token, recordDate, recordTime, expiresAt }\n}\n\nexport async function validateVerificationToken(token: string): Promise<{ valid: boolean; userId?: string; reason?: string }> {\n  const secret = process.env.JWT_SECRET || \"\"\n  if (!secret) return { valid: false, reason: \"Missing JWT_SECRET\" }\n  try {\n    const payload: any = (jwt as any).verify(token, secret)\n    if (payload?.type !== \"email_verification\") return { valid: false, reason: \"Invalid token type\" }\n    const m = (prisma as any).emailVerificationToken\n    const alt = (prisma as any).passwordResetToken\n    const rec = m && typeof m.findUnique === \"function\" ? await m.findUnique({ where: { token } }) : alt && typeof alt.findUnique === \"function\" ? await alt.findUnique({ where: { token } }) : null\n    if (!rec) return { valid: false, reason: \"Token not found\" }\n    if (rec.used) return { valid: false, reason: \"Token already used\" }\n    if (new Date(rec.expiresAt).getTime() < Date.now()) return { valid: false, reason: \"Token expired\" }\n    return { valid: true, userId: rec.userId }\n  } catch (e: any) {\n    return { valid: false, reason: e?.message || \"Invalid token\" }\n  }\n}\n\nexport async function consumeVerificationToken(token: string): Promise<void> {\n  const m = (prisma as any).emailVerificationToken\n  const alt = (prisma as any).passwordResetToken\n  if (m && typeof m.update === \"function\") {\n    await m.update({ where: { token }, data: { used: true } })\n    return\n  }\n  if (alt && typeof alt.update === \"function\") {\n    await alt.update({ where: { token }, data: { used: true } })\n    return\n  }\n  throw new Error(\"Verification token storage unavailable\")\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HP/Downloads/constructionplatform%20%281%29/app/api/auth/verify/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { prisma } from \"@/lib/db\"\nimport { validateVerificationToken, consumeVerificationToken } from \"@/lib/auth/reset\"\n\nfunction fmtDate(d: Date): string {\n  const y = d.getFullYear()\n  const m = String(d.getMonth() + 1).padStart(2, \"0\")\n  const day = String(d.getDate()).padStart(2, \"0\")\n  return `${y}-${m}-${day}`\n}\n\nfunction fmtTime(d: Date): string {\n  const h = String(d.getHours()).padStart(2, \"0\")\n  const min = String(d.getMinutes()).padStart(2, \"0\")\n  return `${h}:${min}`\n}\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url)\n    const token = String(url.searchParams.get(\"token\") || \"\")\n    if (!token) return NextResponse.json({ error: \"Missing token\" }, { status: 400 })\n\n    const val = await validateVerificationToken(token)\n    if (!val.valid || !val.userId) {\n      console.warn(\"Verification attempt failed:\", val.reason)\n      return NextResponse.json({ error: val.reason || \"Invalid token\" }, { status: 400 })\n    }\n\n    const updated = await prisma.user.update({ where: { id: val.userId }, data: { isVerified: true } })\n    await consumeVerificationToken(token)\n    const now = new Date()\n    return NextResponse.json({ ok: true, userId: updated.id, recordDate: fmtDate(now), recordTime: fmtTime(now) })\n  } catch (e: any) {\n    return NextResponse.json({ error: String(e?.message || \"Failed to verify\") }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,SAAS,QAAQ,CAAO;IACtB,MAAM,IAAI,EAAE,WAAW;IACvB,MAAM,IAAI,OAAO,EAAE,QAAQ,KAAK,GAAG,QAAQ,CAAC,GAAG;IAC/C,MAAM,MAAM,OAAO,EAAE,OAAO,IAAI,QAAQ,CAAC,GAAG;IAC5C,OAAO,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK;AAC3B;AAEA,SAAS,QAAQ,CAAO;IACtB,MAAM,IAAI,OAAO,EAAE,QAAQ,IAAI,QAAQ,CAAC,GAAG;IAC3C,MAAM,MAAM,OAAO,EAAE,UAAU,IAAI,QAAQ,CAAC,GAAG;IAC/C,OAAO,GAAG,EAAE,CAAC,EAAE,KAAK;AACtB;AAEO,eAAe,IAAI,OAAgB;IACxC,IAAI;QACF,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC/B,MAAM,QAAQ,OAAO,IAAI,YAAY,CAAC,GAAG,CAAC,YAAY;QACtD,IAAI,CAAC,OAAO,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAgB,GAAG;YAAE,QAAQ;QAAI;QAE/E,MAAM,MAAM,MAAM,IAAA,mJAAyB,EAAC;QAC5C,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,MAAM,EAAE;YAC7B,QAAQ,IAAI,CAAC,gCAAgC,IAAI,MAAM;YACvD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,IAAI,MAAM,IAAI;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,MAAM,UAAU,MAAM,qHAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAAE,OAAO;gBAAE,IAAI,IAAI,MAAM;YAAC;YAAG,MAAM;gBAAE,YAAY;YAAK;QAAE;QACjG,MAAM,IAAA,kJAAwB,EAAC;QAC/B,MAAM,MAAM,IAAI;QAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM,QAAQ,QAAQ,EAAE;YAAE,YAAY,QAAQ;YAAM,YAAY,QAAQ;QAAK;IAC9G,EAAE,OAAO,GAAQ;QACf,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,OAAO,GAAG,WAAW;QAAoB,GAAG;YAAE,QAAQ;QAAI;IAC9F;AACF"}}]
}